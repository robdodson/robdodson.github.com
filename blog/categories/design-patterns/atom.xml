<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Design Patterns | Rob Dodson talks internets]]></title>
  <link href="http://robdodson.me/blog/categories/design-patterns/atom.xml" rel="self"/>
  <link href="http://robdodson.me/"/>
  <updated>2014-03-23T08:29:42-07:00</updated>
  <id>http://robdodson.me/</id>
  <author>
    <name><![CDATA[Rob Dodson]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[JavaScript Design Patterns: Factory]]></title>
    <link href="http://robdodson.me/blog/2012/09/03/javascript-design-patterns-factory/"/>
    <updated>2012-09-03T12:40:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/09/03/javascript-design-patterns-factory</id>
    <content type="html"><![CDATA[<h4><a href="http://robdodson.me/blog/2012/08/03/javascript-design-patterns/">Table of Contents</a></h4>

<p>Factories encapsulate and separate object creation from the rest of your code. In situations where the creation of an object can be complex or subject to change a factory can act as a nice buffer to help keep things tidy. Without proper planning Factories can lead to class explosions; as a result the pattern can be both a blessing and a curse depending on how it's used.</p>

<!--more-->


<h2>Formal Definition</h2>

<h4>Factory Method</h4>

<p><blockquote><p>Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.</p><footer><strong>GoF</strong> <cite>Design Patterns: Elements of Reusable Object-Oriented Software</cite></footer></blockquote></p>

<h4>Abstract Factory</h4>

<p><blockquote><p>Provide an interface for creating families of related or dependent objects without specifying their concrete classes.</p><footer><strong>GoF</strong> <cite>Design Patterns: Elements of Reusable Object-Oriented Software</cite></footer></blockquote></p>

<h3>Also Known As</h3>

<ul>
<li>Virtual Constructor (<strong>Factory Method</strong>)</li>
<li>Kit (<strong>Abstract Factory</strong>)</li>
</ul>


<h2>Simple Factory vs Factory Method vs Abstract Factory</h2>

<p>The phrase "Factory Pattern" is rather overloaded so I'm going to give you a quick crash course in the three main types of factories.</p>

<p>A <strong>simple factory</strong> is an object which encapsulates the creation of another object, shielding that code from the rest of your application.</p>

<p><code>js
var user = UserFactory.createUser();
</code>
It's common to parameterize simple factory methods to increase the number of products they're able to return.</p>

<p><code>js
var admin = UserFactory.createUser('admin');
var customer = UserFactory.createUser('customer');
</code>
The actual implementaiton of <code>createUser</code> might look something like this:</p>

<p>``` js
UserFactory.createUser = function(type) {</p>

<pre><code>if (type == 'admin') {
    return new Admin();
} else if (type == 'customer') {
    return new Customer();
}
</code></pre>

<p>};
<code>``
Typically the return value from a factory is known as the</code>Product<code>. In the case of our</code>UserFactory<code>there are two Products:</code>Admin<code>and</code>Customer`. It's important for these products to maintain a consistent interface so the client can use any product from our factory without needing to do elaborate checks to see if a particular method exists.</p>

<h3>Factory Method</h3>

<p>While the Simple Factory is a nice start and good for many situations it's possible to extend this even further through the use of the <strong>Factory Method</strong> pattern.</p>

<p><blockquote><p>The Factory Method Pattern defines an interface<br/>for creating an object, but lets subclasses decide which<br/>class to instantiate.  Factory Method lets a class defer<br/>instantiation to subclasses.</p><footer><strong>Elisabeth Freeman</strong> <cite>Head First Design Patterns</cite></footer></blockquote></p>

<p>Factory Method defines one method, <code>createThing</code> for instance, which is overriden by subclasses who decide what to return. The Factories and Products must conform to interfaces for clients to be able to use them.</p>

<p>In <em>Head First Design Patterns</em> a Factory Method pattern is used to allow a PizzaStore to define many subclasses such as ChicagoPizzaStore, CaliforniaPizzaStore, NewYorkPizzaStore. Each subclass overrides <code>createPizza</code> and returns its own particular style of pizza (ie: a ChicagoPizza or a CaliforniaPizza). The main take away is that there is only one method, <code>createPizza</code>, that does anything. By subclassing and overriding this method we can offer aditional flexibility beyond what's possible with the Simple Factory.</p>

<h3>Abstract Factory</h3>

<p>Unlike the Factory Method pattern, <strong>Abstract Factory</strong> defines any number of methods which return Products.</p>

<p><blockquote><p>The Abstract Factory Pattern provides an interface<br/>for creating families of related or dependent objects<br/>without specifying their concrete classes.</p><footer><strong>Elisabeth Freeman</strong> <cite>Head First Design Patterns</cite></footer></blockquote></p>

<p>Again in <em>Head First Design Patterns</em>, an Abstract Factory pattern is used to provide different Pizza ingredients depending on the type of Pizza. For instance, a ChicagoPizza would be given a ChicagoPizzaIngredients factory with methods like <code>createDough</code>, <code>createSauce</code>, <code>createCheese</code>, etc. A CaliforniaPizzaIngredients factory would also implement <code>createDough</code>, <code>createSauce</code> and <code>createCheese</code>. In this way the factories would be interchangeable.</p>

<p>The authors are keen to point out that the methods of the Abstract Factory (<code>createDough</code>, <code>createSauce</code>, etc) look very similar to the Factory Method (<code>createPizza</code>). One way of thinking about things is that an Abstract Factory can be composed of Factory Methods.</p>

<h2>The Factory Method in JavaScript</h2>

<p>Since I've already shown a basic Simple Factory let's take a stab at doing the Factory Method in JS. We'll continue with the PizzaStore theme since I've already spelled out how each pattern applies to it. We're going to do this without the use of the <code>new</code> keyword and instead we'll take advantage of JavaScript's prototypes. How you ask?</p>

<h3>The very awesome Object.create</h3>

<p>ECMAScript 5 introduced a new method of the <code>Object</code> prototype called <code>create</code>. You can read up on it in full detail <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/create">on MDN.</a> In a nutshell it lets you pass in a prototype and receive a new object which points to that prototype. <code>Object.create</code> is actually a simple Factory Method! Here's an example:</p>

<p><code>js
var firstPizzaStore = Object.create(PizzaStore);
firstPizzaStore.createPizza(); // returns 'Generic pizza created'
</code></p>

<p>One very cool feature of <code>Object.create</code> is that it accepts a properties object which is then mixed in to the returned object. The code can get a little verbose since it uses <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/defineProperty">defineProperty syntax</a> so instead let's steal a function from <a href="http://yehudakatz.com/2011/08/12/understanding-prototypes-in-javascript/">Yehuda Katz</a> which lets us do something very similar.</p>

<p>``` js
var fromPrototype = function(prototype, object) {</p>

<pre><code>var newObject = Object.create(prototype);
for (var prop in object) {
    if (object.hasOwnProperty(prop)) {
        newObject[prop] = object[prop];
    }
}
</code></pre>

<p>  return newObject;
};
<code>``
Now that we have that we can continue on our way. One quick caveat though! Some browsers \*cough\* **IE** \*cough\* don't support</code>Object.create` so we need to shim it. Thankfully MDN has got our back:</p>

<p>``` js
// Polyfill
if (!Object.create) {</p>

<pre><code>Object.create = function (o) {
    if (arguments.length &gt; 1) {
        throw new Error('Object.create implementation only accepts the first parameter.');
    }
    function F() {}
    F.prototype = o;
    return new F();
};
</code></pre>

<p>}
```
Drop that into your page and you should be able to use Object.create like we are above. Note that the shim does not support the second properties object. For our purposes that's ok but definitely keep it in mind if you're thinking of using it.</p>

<h3>Back to the Factory Method</h3>

<p>With <code>Object.create</code> and <code>fromPrototype</code> in hand we're ready to tackle our first Factory Method.</p>

<p>Let's start by creating a PizzaStore:</p>

<p>``` js
// Define the Pizza product
var Pizza = {</p>

<pre><code>description: 'Plain Generic Pizza'
</code></pre>

<p>};</p>

<p>// And the basic PizzaStore
var PizzaStore = {</p>

<pre><code>createPizza: function(type) {
    if (type == 'cheese') {
        return fromPrototype(Pizza, {
            description: 'Cheesy, Generic Pizza'
        });
    } else if (type == 'veggie') {
        return fromPrototype(Pizza, {
            description: 'Veggie, Generic Pizza'
        });
    }
}
</code></pre>

<p>};
```</p>

<p>Easy enough. Ok now let's extend the PizzaStore so we have two variations: ChicagoPizzaStore and CaliforniaPizzaStore.</p>

<p>``` js
var ChicagoPizzaStore = fromPrototype(PizzaStore, {</p>

<pre><code>createPizza: function(type) {
    if (type == 'cheese') {
        return fromPrototype(Pizza, {
            description: 'Cheesy, Deep-dish Chicago Pizza'
        });
    } else if (type == 'veggie') {
        return fromPrototype(Pizza, {
            description: 'Veggie, Deep-dish Chicago Pizza'
        });
    }
}
</code></pre>

<p>});</p>

<p>var CaliforniaPizzaStore = fromPrototype(PizzaStore, {</p>

<pre><code>createPizza: function(type) {
    if (type == 'cheese') {
        return fromPrototype(Pizza, {
            description: 'Cheesy, Tasty California Pizza'
        });
    } else if (type == 'veggie') {
        return fromPrototype(Pizza, {
            description: 'Veggie, Tasty California Pizza'
        });
    }
}
</code></pre>

<p>});</p>

<p>// Elsewhere in our app...
var chicagoStore = Object.create(ChicagoPizzaStore);
var pizza = chicagoStore.createPizza('veggie');
console.log(pizza.description); // returns 'Veggie, Deep-dish Chicago Pizza'
```</p>

<h2>The Abstract Factory in JavaScript</h2>

<p>Since we have a variety of pizza styles we might also have a variety of ingredients. Let's see if we can accomodate all the different kinds.</p>

<p>``` js
var Ingredients = {</p>

<pre><code>createDough: function() {
    return 'generic dough';
},
createSauce: function() {
    return 'generic sauce';
},
createCrust: function() {
    return 'generic crust';
}
</code></pre>

<p>};</p>

<p>Ingredients.createChicagoStyle = function() {</p>

<pre><code>return fromPrototype(Ingredients, {
    createDough: function() {
        return 'thick, heavy dough';
    },
    createSauce: function() {
        return 'rich marinara';
    },
    createCrust: function() {
        return 'deep-dish';
    }
});
</code></pre>

<p>};</p>

<p>Ingredients.createCaliforniaStyle = function() {</p>

<pre><code>return fromPrototype(Ingredients, {
    createDough: function() {
        return 'light, fluffy dough';
    },
    createSauce: function() {
        return 'tangy red sauce';
    },
    createCrust: function() {
        return 'thin and crispy';
    }
});
</code></pre>

<p>};</p>

<p><code>``
In the above example</code>Ingredients` is our Abstract Factory. We know that for every
different kind of pizza we'll need different ingredients and therefore a new Factory Method. We also know that we have different styles of pizza so we'll need Chicago style ingredients and California style ingredients. When a client wishes to grab some ingredients for a particular kind of pizza they just say:</p>

<p><code>js
var californiaIngredients = Ingredients.createCaliforniaStyle();
californiaIngredients.createCrust(); // returns 'thin and crispy';
</code>
The object that is returned by the call <code>createCaliforniaStyle</code> is the concrete implementation of our Abstract Ingredients object. In other words, if <code>Ingredients</code> is the Abstract Factory, then the object returned by <code>createCaliforniaStyle</code> could also be thought of as a <code>CaliforniaIngredients</code> object. It is a <em>subclass</em> of <code>Ingredients</code> if you want to think of it that way. The returned object extends <code>Ingredients</code> and overrides its Factory Methods with its own methods. In so doing we provide a lot of additional flexibility to our app. If we want to add a Hawaiian style ingredients we just add a <code>createHawaiianStyle</code> method.</p>

<p>If you recall from <a href="http://robdodson.me/blog/2012/08/27/javascript-design-patterns-decorator/">the previous article on Decorators</a> we talked about the <strong>Open-Closed Principle</strong> which states that "classes should be open for extension but closed for modification." You'll notice that adding a <code>createHawaiianStyle</code> method would actually violate this principle so it should be noted that when using an Abstract Factory approach you'll probably have to reopen the class/object a few times to modify it. Not ideal but depending on your use case this might not be such  big deal and you might prefer the flexibility and organization that the factory offers.</p>

<h2><a href="https://github.com/robdodson/JavaScript-Design-Patterns/tree/master/factory/">Grab the Example Source</a></h2>

<h2>Related Patterns</h2>

<ul>
<li>Template Methods: Factory Methods are usually called within Template Methods.</li>
<li><a href="http://robdodson.me/blog/2012/08/08/javascript-design-patterns-singleton/">Singleton</a>: A concrete factory is often a singleton.</li>
</ul>


<p><small><cite style="color:#AAA;">Gamma, Erich; Helm, Richard; Johnson, Ralph; Vlissides, John (1994-10-31). Design Patterns: Elements of Reusable Object-Oriented Software. Pearson Education (USA).</cite></small></p>

<hr>


<br>


<h4><a href="http://robdodson.me/blog/2012/08/03/javascript-design-patterns/">Table of Contents</a></h4>

<br>


<p>Thanks for reading! If you have questions or feedback please leave a comment below. - Rob</p>

<p>You should follow me on Twitter <a href="http://twitter.com/rob_dodson">here.</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript Design Patterns: Decorator Update]]></title>
    <link href="http://robdodson.me/blog/2012/08/30/javascript-design-patterns-decorator-pt-2/"/>
    <updated>2012-08-30T18:07:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/08/30/javascript-design-patterns-decorator-pt-2</id>
    <content type="html"><![CDATA[<p><a href="http://robdodson.me/blog/2012/08/27/javascript-design-patterns-decorator/">Yesterday's post</a> drew a lot of traffic from Reddit and with it came some really good feedback. If you haven't read the <a href="http://robdodson.me/blog/2012/08/27/javascript-design-patterns-decorator/">previous post</a> please do so first and then come back here.</p>

<p>I want to go through some of what was said so I can refine my examples and also clear up any confusion.</p>

<!--more-->


<h2>That prototype example sucked!</h2>

<p>OK let me start off by apologizing for even including that second example (the <code>Sale</code> decorators). It was meant as a kind of fun academic exercise but I tried to make it clear that I wasn't suggesting anyone actually implement it. Redditor gizmo490 pointed out that for the pattern to actually work you would have to overwrite all the methods of the <code>Sale</code> object or risk working in the wrong context. You can see our full discussion <a href="http://www.reddit.com/r/javascript/comments/z0z2j/decorators_in_javascript_hope_you_enjoy/c60qb0c">here.</a></p>

<p>So I'll just say if you're considering that second example: Stop. Just don't do it. It is way too much code.</p>

<h2>We don't necessarily need all those objects</h2>

<p>Another Redditor, Draders, pointed out that the decorator objects aren't really necessary since we can just put functions directly into the decoratorsList.</p>

<p><code>js
// This is presuming that `add` pushes a function into the
// list of decorators
validator.add('zipcode', validateZipCodeFunction);
</code>
If you want <code>validateZipCodeFunction</code> to be reusable you'll have to define it somewhere and attaching it to the Validator object is probably a fine choice. In the end it's a bit less code so definitely something to think about.</p>

<h2>Finally, the power of CLOSURES!</h2>

<p>Finally, and this is really the reason why I wanted to write this update, Redditor emehrkay pointed out that my examples are basically ignoring the power of JS functions and closures. <a href="http://www.reddit.com/r/javascript/comments/z0z2j/decorators_in_javascript_hope_you_enjoy/c60rl7x">In his quick and dirty example</a> he shows how to achieve a similar goal with much less code:</p>

<p>``` js
function test(arg){</p>

<pre><code>return arg + arg;
</code></pre>

<p>}</p>

<p>function testDecorator(fn, args){</p>

<pre><code>var arg = args[0] * 2;

return fn(arg);
</code></pre>

<p>}</p>

<p>function decorate(dec, fn, args){</p>

<pre><code>return function(){
    return dec(fn, args);
}
</code></pre>

<p>}</p>

<p>x = decorate(testDecorator, test, [2])();
console.log(x)
```</p>

<p>So here's my attempt to recreate the <code>Sale</code> example but using more of emehrkay's approach:</p>

<p>``` js
function Sale(price) {</p>

<pre><code>this.price = price || 100;
</code></pre>

<p>}</p>

<p>Sale.prototype.getPrice = function() {</p>

<pre><code>return this.price;
</code></pre>

<p>};</p>

<p>Sale.prototype.setPrice = function(price) {</p>

<pre><code>this.price = price;
</code></pre>

<p>};</p>

<p>function usd(fn, context) {</p>

<pre><code>var price = fn.call(context);
return "$" + price;
</code></pre>

<p>}</p>

<p>function decorate(dec, fn, context) {</p>

<pre><code>return function() {
    return dec.call(context, fn, context);
};
</code></pre>

<p>}</p>

<p>// Let's run it!
var sale = new Sale(50);</p>

<p>// Decorate our getPrice method. We'll just add
// some extra dollar signs to the output.
sale.getPrice = decorate(usd, sale.getPrice, sale);
sale.getPrice = decorate(usd, sale.getPrice, sale);
sale.getPrice = decorate(usd, sale.getPrice, sale);
console.log(sale.getPrice()); // output: $$$50</p>

<p>// Test to make sure other methods can still
// access the price in the correct context
sale.setPrice(100);
console.log(sale.getPrice()); // output: $$$100
<code>``
Since we're kind of mixing OO and functional style here the one caveat is that you have to pass the context to your decorators so when they call</code>getPrice` they know which instance they're referring to. So the code is a little funky but still interesting and if anyone can think of a way to write it cleaner I'm all ears!</p>

<h2><a href="https://github.com/robdodson/JavaScript-Design-Patterns/tree/master/decorator/">Grab the Example Source</a></h2>

<p>Thanks for reading! If you have questions or feedback please leave a comment below. - Rob</p>

<p>You should follow me on Twitter <a href="http://twitter.com/rob_dodson">here.</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript Design Patterns: Decorator]]></title>
    <link href="http://robdodson.me/blog/2012/08/27/javascript-design-patterns-decorator/"/>
    <updated>2012-08-27T09:59:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/08/27/javascript-design-patterns-decorator</id>
    <content type="html"><![CDATA[<h4><a href="http://robdodson.me/blog/2012/08/03/javascript-design-patterns/">Table of Contents</a></h4>

<p><a href="http://robdodson.me/blog/2012/08/30/javascript-design-patterns-decorator-pt-2/">Update: Part 2 has been posted!</a></p>

<p>A Decorator is an object which adds functionality to another object dynamically. It can be used to enhance the behavior of an object without requiring the author to reopen its class. While Decorators might feel a little weird to implement in static languages they're extremely simple in JavaScript due to the ease with which JS passes around functions and handles dynamic types.</p>

<!--more-->


<h2>Formal Definition</h2>

<p><blockquote><p>Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.</p><footer><strong>GoF</strong> <cite>Design Patterns: Elements of Reusable Object-Oriented Software</cite></footer></blockquote></p>

<h3>Also Known As</h3>

<ul>
<li>Wrapper</li>
</ul>


<h2>When to use it</h2>

<ul>
<li><p>When you'd like to add responsibilities to individual objects dynamically (i.e. without subclassing/inheritence).</p></li>
<li><p>When you'd like to be able to remove the functionality at a later time. An <code>undecorate</code> method, for instance.</p></li>
<li><p>When extension by subclassing would be unmanageable or lead to a class explosion. For instance, if a <code>Vehicle</code> class is subclassed by 30 other vehicle objects with only minor differences.</p></li>
</ul>


<h2>Pros and Cons</h2>

<ul>
<li><p><strong>Pro</strong>: More flexible than inheritance.</p></li>
<li><p><strong>Pro</strong>: Avoids feature-laden classes high up in the hierarchy.</p></li>
<li><p><strong>Con</strong>: A decorator and its component aren’t identical.</p></li>
<li><p><strong>Con</strong>: Lots of little objects.</p></li>
</ul>


<h2>A Brief Explanation</h2>

<p>The Decorator pattern is very similar to one we've addressed earlier, called <a href="http://robdodson.me/blog/2012/08/03/javascript-design-patterns-strategy/">Strategy.</a> The differences between the two can be subtle but usually a decorator <em>enhances</em>, layers upon or "decorates" the object or method it's wrapping. In contrast, a strategy will replace a method's algorithm completely.</p>

<p>The primary benefit of the Decorator pattern is that you can take a rather vanilla object and wrap it in more advanced behaviors. For instance a view which renders a plain window can have decorators to add different backgrounds, scroll bars, borders, etc. The underlying code, or guts, of the window object remains the same while the decorators provide a new <em>skin.</em></p>

<p>Decorators are not limited to visual components. In fact much of the <code>java.io</code> package is composed of Decorators which add additional functionality such as buffering file streams and adding line numbers. A similar application to JavaScript might involve decorating I/O in Node.js. For instance, incoming data might need to be converted to ASCII and then compressed in some way. It might not <em>always</em> need to be converted to ASCII and it might not <em>always</em> need to be compressed. In this scenario we can apply or remove I/O decorators at runtime changing the behavior of our object instead of writing a big class with a bunch of cross-cutting concerns.</p>

<h2>Enough Talk! COOOOODE!!!</h2>

<p>Ok so let's do an example. We're going to create a <code>Validator</code> class which looks at the contents of a form and adds error messages to an array if anything in the form is not correct. We want our <code>Validator</code> to be really simple so it'll just have two methods: <code>validate</code> and <code>decorate</code>. As the name implies <code>validate</code> will tell our validator to compare the form against its internal rules. We'll use <code>decorate</code> to specify those rules. The <code>decorate</code> method will accept a String, such as 'hasAge' or 'hasZipCode' which corresponds to an actual function. We'll collect these functions in a list and compare the contents of the form to each item in the list.</p>

<p>We'll start with the constructor and <code>decorate</code> method:</p>

<p>``` js
function Validator () {</p>

<pre><code>this.errors = [];
this.decoratorsList = [];
</code></pre>

<p>}</p>

<p>Validator.prototype.decorate = function(name) {</p>

<pre><code>this.decoratorsList.push(name);
</code></pre>

<p>};
<code>``
We'll collect any error messages in the</code>errors<code>array. We could write a method like</code>validator.hasErrors()` to check the length and contents of the array but for now I'll leave that unspecified. Just know that if we do come across an error we'll toss it in there.</p>

<p>The <code>decoratorsList</code> will hold all of our decorator functions. This is not how the Gang of Four does things, or how you will see the Decorator pattern presented in languages like Java or C++, but that's because they're using static languages which don't do well with functions being passed around. In our case since JavaScript functions are objects we can pass our decorators into a collection to have them called sequentially. This is the easier approach recommended by <a href="https://twitter.com/stoyanstefanov">Stoyan Stefanov</a> in <a href="http://www.amazon.com/JavaScript-Patterns-Stoyan-Stefanov/dp/0596806752">JavaScript Patterns.</a> A little later I'll show you the "hard" approach and you can decide which you prefer ;)</p>

<p>OK moving on... Let's define some decorator functions. We'll add an object to our constructor called <code>decorators</code> and we'll attach our functions to it.</p>

<p>``` js
Validator.decorators = {};</p>

<p>Validator.decorators.hasName = {</p>

<pre><code>validate: function(form) {
    // Code to verify presence of name...

    // If no name found...
    this.errors.push('no name!');
}
</code></pre>

<p>};</p>

<p>Validator.decorators.hasAge = {</p>

<pre><code>validate: function(form) {
    // Code to verify presence of age...

    // If no age found...
    this.errors.push('no age!');
}
</code></pre>

<p>};</p>

<p>Validator.decorators.hasZipCode = {</p>

<pre><code>validate: function(form) {
    // Code to verify presence of zip code...

    // If no zip found...
    this.errors.push('no zip!');
}
</code></pre>

<p>};
```</p>

<p>Each decorator is actually an object which implements the same interface as our <code>Validator</code> object. When we have all of our decorators added to our <code>decoratorsList</code> we'll be able to loop through and call <code>validate</code> on each one.</p>

<p>``` js
Validator.prototype.validate = function(form) {</p>

<pre><code>var i,
    max,
    name;

this.form = form;

max = this.decoratorsList.length;
for (i = 0; i &lt; max; i++) {
    name = this.decoratorsList[i];
    Validator.decorators[name].validate.call(this, form);
};
</code></pre>

<p>};
<code>``
At last we come to the</code>validate<code>method. It first receives an object containing all of our form data. Next it prepares to loop through our collection of decorators. We use the name of the decorator object as a key and</code>call<code>its</code>validate<code>method, passing in</code>this<code>for our context and also the form object as an argument. This way all of the validators will execute in the context of our</code>Validator` instance and they should all have access to the form data.</p>

<p>Let's try it out!</p>

<p><code>js
var validator = new Validator();
validator.decorate('hasName');
validator.decorate('hasAge');
validator.decorate('hasZipCode');
validator.validate({}); // we'll just use a blank object in place of real form data
console.log(validator.errors);
</code></p>

<p>We aren't really doing any validation at this point so our <code>console.log</code> at the end should output an array with 3 error messages, one from each of the validator decorators. But there you go, you've now got a fully decorated <code>validate</code> function. What was once rather vanilla can have all sorts of new and interesting validations applied to it!</p>

<h2>What if my Decorators need additional arguments?</h2>

<p>The above example gets us started decorating but it leaves some room for improvement. For starters what if we want to pass additional arguments to our validation functions? Let's revamp this thing just a bit so we can get really fancy...</p>

<p>```js
function Validator () {</p>

<pre><code>this.errors = [];
this.decoratorsList = [];
</code></pre>

<p>}</p>

<p>Validator.prototype.decorate = function(name, args) {</p>

<pre><code>this.decoratorsList.push({ name: name, args: args });
</code></pre>

<p>};</p>

<p>Validator.decorators = {};</p>

<p>Validator.decorators.hasName = {</p>

<pre><code>validate: function(form, args) {
    // Code to verify presence of name...

    this.errors.push('no name!');
}
</code></pre>

<p>};</p>

<p>Validator.decorators.hasAge = {</p>

<pre><code>validate: function(form, args) {
    // Code to verify presence of age...

    this.errors.push('no age!');
}
</code></pre>

<p>};</p>

<p>Validator.decorators.hasZipCode = {</p>

<pre><code>validate: function(form, args) {
    // Code to verify presence of zip code...

    this.errors.push('no zip!');
}
</code></pre>

<p>};</p>

<p>Validator.prototype.validate = function(form) {</p>

<pre><code>var i,
    max,
    temp,
    name,
    args;

this.form = form;

max = this.decoratorsList.length;
for (i = 0; i &lt; max; i++) {
    temp = this.decoratorsList[i];
    name = temp.name;
    args = temp.args;
    Validator.decorators[name].validate.call(this, form, args);
};
</code></pre>

<p>};
<code>``
This time we are passing an optional hash to our</code>decorate` method which is stored along with its corresponding decorator object. If you've ever used validators in Rails this should feel similar. Time to see it in action!</p>

<p><code>js
var validator = new Validator();
validator.decorate('hasName', { length: 5 });
validator.decorate('hasAge', { minimum: 21 });
validator.decorate('hasZipCode');
validator.validate({}); // some form data. in this case just an anonymous object
console.log(validator.errors);
</code></p>

<h2>Time to do things the hard way...</h2>

<p>I promised I would show you the more classical example of Decorator and since I am a man of my word I <em>guess</em> you can see it... I would not recommend using this approach because it can require overwriting all of your methods to make sure you're always in the correct context. Still, as a kind of academic observation it's a cool example and demonstrates how JS can emulate other languages. I'm taking this code almost verbatim from <a href="http://www.amazon.com/JavaScript-Patterns-Stoyan-Stefanov/dp/0596806752">JavaScript Patterns</a> so full credit goes to Stoyan for coming up with it.</p>

<p>In this example we're going to format a Sale price so that it can work for both U.S. and Canadian stores. This means applying different tax rates and outputting the text with different currency symbols.</p>

<p>``` js
function Sale(price) {</p>

<pre><code>this.price = price || 100;
</code></pre>

<p>}</p>

<p>Sale.prototype.getPrice = function() {</p>

<pre><code>return this.price;
</code></pre>

<p>};
<code>``
Things start off very similar to our last example. Instead of</code>validate<code>the method we're interested in this time is</code>getPrice<code>. If you've been paying attention you'll notice that in our previous example</code>validate<code>was rather complex. Yet</code>getPrice` is so...simple. Hmm...</p>

<p>Let's move on to the decorators.</p>

<p>``` js
Sale.decorators = {};</p>

<p>Sale.decorators.fedtax = {</p>

<pre><code>getPrice: function() {
    var price = this._super.getPrice();
    price += price * 5 / 100;
    return price;
}
</code></pre>

<p>};</p>

<p>Sale.decorators.quebec = {</p>

<pre><code>getPrice: function() {
    var price = this._super.getPrice();
    price += price * 7.5 / 100;
    return price;
}
</code></pre>

<p>};</p>

<p>Sale.decorators.usd = { // U.S. dollars</p>

<pre><code>getPrice: function() {
    return "$" + this._super.getPrice().toFixed(2);
}
</code></pre>

<p>};</p>

<p>Sale.decorators.cdn = { // Canadian dollars</p>

<pre><code>getPrice: function() {
    return "CDN$" + this._super.getPrice().toFixed(2);
}
</code></pre>

<p>};
<code>``
This may look similar to the last example but take note of the use of</code><em>super<code>. The</code></em>super` property is actually a reference to a parent class instance. We'll use this reference to travel up the chain of decorators, performing an operation and returning the price at each stop.</p>

<p>This leads us to the <code>decorate</code> method:</p>

<p>``` js
Sale.prototype.decorate = function (decorator) {</p>

<pre><code>var F = function () {},
overrides = this.constructor.decorators[decorator],
i,
newobj;

// Create prototype chain
F.prototype = this;
newobj = new F();
newobj._super = F.prototype;

// Mixin properties/methods of our decorator
// Overriding the ones from our prototype
for (i in overrides) {
    if (overrides.hasOwnProperty(i)) {
        newobj[i] = overrides[i];
    }
}

return newobj;
</code></pre>

<p>}
<code>``
If you're unfamiliar with JavaScript prototypes this can look a little daunting. We're using a pattern that [JavaScript Patterns](http://www.amazon.com/JavaScript-Patterns-Stoyan-Stefanov/dp/0596806752) refers to as *Rented Constructor* in order to essentially take a snapshot of our current object, store it in</code>_super` and then mixin new decorator methods. Let's see it in action to clarify things a bit better.</p>

<p><code>js
var sale = new Sale(50);
sale = sale.decorate('fedtax');
sale = sale.decorate('cdn');
console.log(sale.getPrice()); // outputs $CDN52.50
</code>
You'll notice that each time we call <code>decorate</code> we have to re-assign the sale variable to a new instance. Each new instance has a reference to the previous sale object. When we finally call <code>getPrice</code> it walks up this chain of instances and calls <code>getPrice</code> on each stop along the way. In the end we have something which is functionally identical to our first example but potentially a lot harder to understand. In other words, stick with the first approach! Also be sure to <a href="http://robdodson.me/blog/2012/08/30/javascript-design-patterns-decorator-pt-2/">see my update</a> which discusses this example a bit more and points out a few more of its flaws. Again, it's a neat idea to mess around with but there are much easier ways.</p>

<h2>The Open-Closed Principle</h2>

<p>I'm going to go off on a quick tangent here because of something I saw in <a href="http://www.amazon.com/First-Design-Patterns-Elisabeth-Freeman/dp/0596007124">Head First Design Patterns.</a> There's a common heuristic in software design known as the <strong>Open-Closed Principle</strong> which states that "classes should be open for extension but closed for modification." Let's explore this concept with our Sale object.</p>

<p>Consider the following bit of code:</p>

<p>``` js
function Sale(price) {</p>

<pre><code>this.price = price || 100;
</code></pre>

<p>}</p>

<p>Sale.prototype.getPrice = function() {</p>

<pre><code>return this.price;
</code></pre>

<p>};
```
You should be able to look at this snippet of code and say that it's almost certainly bug free. Now let's pretend we aren't using decorators and our boss comes to us and says we need to add US and Canadian taxes and currency symbols.</p>

<p>"<em>Hm...I guess that means I'll need to pass those parameters into the constructor and then write some booleans or something to check if we're Canadian or US... Or maybe I'll put them all in a hash... Or...</em>"</p>

<p>Regardless of what we choose to do, if it involves opening up the class then there's a chance that we'll compromise our previous snippet of code. The more times we do this the more we increase the likelihood that we'll introduce a bug which might go uncaught for a long time. Eventually what started off as extremely simple, bug-free code, can turn into a rat's nest.</p>

<p>So, where possible, try to avoid reopening classes and find ways to extend their functionality. This can mean simply subclassing the parent, or using one of the many design patterns we'll be covering.</p>

<h2><a href="https://github.com/robdodson/JavaScript-Design-Patterns/tree/master/decorator/">Grab the Example Source</a></h2>

<h2>Related Patterns</h2>

<ul>
<li><p>Adapter: A decorator is different from an adapter in that a decorator only changes an object’s responsibilities, not its interface; an adapter will give an object a completely new interface.</p></li>
<li><p>Composite: A decorator can be viewed as a degenerate composite with only one component. However, a decorator adds additional responsibilities—it isn't intended for object aggregation.</p></li>
<li><p><a href="http://robdodson.me/blog/2012/08/03/javascript-design-patterns-strategy/">Strategy:</a> A decorator lets you change the skin of an object; a strategy lets you change the guts. These are two alternative ways of changing an object.</p></li>
</ul>


<p><small><cite style="color:#AAA;">Gamma, Erich; Helm, Richard; Johnson, Ralph; Vlissides, John (1994-10-31). Design Patterns: Elements of Reusable Object-Oriented Software. Pearson Education (USA).</cite></small></p>

<hr>


<br>


<h4><a href="http://robdodson.me/blog/2012/08/03/javascript-design-patterns/">Table of Contents</a></h4>

<br>


<p>Thanks for reading! If you have questions or feedback please leave a comment below. Also be sure to <a href="http://robdodson.me/blog/2012/08/30/javascript-design-patterns-decorator-pt-2/">checkout Part 2 which covers even more ways to do decorators!</a> - Rob</p>

<p>You should follow me on Twitter <a href="http://twitter.com/rob_dodson">here.</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript Design Patterns: Observer]]></title>
    <link href="http://robdodson.me/blog/2012/08/16/javascript-design-patterns-observer/"/>
    <updated>2012-08-16T13:19:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/08/16/javascript-design-patterns-observer</id>
    <content type="html"><![CDATA[<h4><a href="http://robdodson.me/blog/2012/08/03/javascript-design-patterns/">Table of Contents</a></h4>

<p>Observer is one of the most popular design patterns and chances are you're probably already using it. If you've ever written an event listener with <code>addEventListener</code> or used one of jQuery's many versions: <code>on</code>, <code>delegate</code>, <code>live</code>, <code>click</code>, etc... then you should already be comfortable with the concept. In a nutshell the Observer pattern allows a <strong>Subject</strong> to publish updates to a group of <strong>Observers</strong>. The Subject maintains a list of Observers and provides an interface for objects to register as Observers. Otherwise the Subject doesn't care who or what is listening to it. In this way the Subject is decoupled from the Observers allowing easy replacement of one Observer for another or even one Subject for another so long as it maintains the same lexicon of events/notifications.</p>

<!--more-->


<h2>Formal Definition</h2>

<p><blockquote><p>Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.</p><footer><strong>GoF</strong> <cite>Design Patterns: Elements of Reusable Object-Oriented Software</cite></footer></blockquote></p>

<h3>Also Known As</h3>

<ul>
<li>Dependents</li>
<li>Publish-Subscribe</li>
</ul>


<h2>When to use it</h2>

<ul>
<li><p>When the state or actions of one object depends on the state or actions of another object.</p></li>
<li><p>When changing one object necessitates a change to an unknown number of <em>other</em> objects.</p></li>
<li><p>When an object should be able to notify other objects of changes without knowing anything about these other objects.</p></li>
</ul>


<h2>Pros and Cons</h2>

<ul>
<li><p><strong>Pro:</strong> Very loose coupling between objects.</p></li>
<li><p><strong>Pro:</strong> The ability to broadcast changes and updates.</p></li>
<li><p><strong>Con:</strong> Potentially unexpected updates and sequencing issues.</p></li>
</ul>


<h2>The Many Faces of Observer</h2>

<p>Because of its popularity the Observer pattern often goes by a few different names. The primary objects are the <strong>Subject</strong> and the <strong>Observers</strong> though sometimes they are referred to as <strong>Publisher</strong>/<strong>Subscribers</strong> or <strong>Event Dispatcher</strong>/<strong>Listeners</strong>. Although you can definitely split hairs regarding the actual implementation of this pattern, in essence we're usually talking about the same thing. When the Subject's state changes it sends out notifications, unaware of who its Observers are. The Observers, in turn, perform some action in response to this update.</p>

<p>I'm going to heavily quote (*cough* <em>plagiarize</em> *cough*) the wonderful <a href="http://www.amazon.com/JavaScript-Patterns-Stoyan-Stefanov/dp/0596806752">JavaScript Patterns by Stoyan Stefanov</a> to sum up all the parts of an Observer/Pub-Sub relationship:</p>

<p><em>"The publisher object needs to have a property <code>subscribers</code> that is an array storing all subscribers. The act of subscription is merely adding to this array. When an event occurs, the publisher loops through the list of subscribers and notifies them. The notification means calling a method of the subscriber object. Therefore, when subscribing, the subscriber provides one of its methods to the publisher’s subscribe() method.</em></p>

<p><em>The publisher can also provide unsubscribe(), which means removing from the array of subscribers. The last important method of the publisher is publish(), which will call the subscribers’ methods."</em></p>

<p>Here is Stoyan's Pub/Sub implementation. Note that the <code>on</code> function accepts a <code>context</code> argument which allows you to set the handler's context and in turn, the value of <code>this</code>. We'll discuss this a bit more later.</p>

<p>``` js</p>

<p>var publisher = {</p>

<pre><code>subscribers: {
    any: [] // event type: subscribers
},
on: function(type, fn, context) {
    type = type || 'any';
    fn = typeof fn === 'function' ? fn : context[fn];
    if (typeof this.subscribers[type] === "undefined") {
        this.subscribers[type] = [];
    }
    this.subscribers[type].push({ fn: fn, context: context || this });
},
remove: function(type, fn, context) {
    this.visitSubscribers('unsubscribe', type, fn, context);
},
fire: function(type, publication) {
    this.visitSubscribers('publish', type, publication);
},
visitSubscribers: function(action, type, arg, context) {
    var pubtype = type || 'any',
        subscribers = this.subscribers[pubtype],
        i,
        max = subscribers ? subscribers.length : 0;

    for (i = 0; i &lt; max; i += 1) {
        if (action === 'publish') {
            // Call our observers, passing along arguments
             subscribers[i].fn.call(subscribers[i].context, arg);
        } else {
            if (subscribers[i].fn === arg &amp;&amp; subscribers[i].context === context) {
                subscribers.splice(i, 1);
            }
        }
    }
}
</code></pre>

<p>};</p>

<p>```</p>

<p>In practice using the <code>publisher</code> might look something like this:</p>

<p>``` js
function handleLogin() {</p>

<pre><code>console.log('we haz a users!');
</code></pre>

<p>}</p>

<p>publisher.subscribe('login.complete', handleLogin);</p>

<p>// ... .
// Elaborate user login process...</p>

<p>publisher.publish('login.complete');
```</p>

<h2>Mind the Context</h2>

<p>In JavaScript the keyword <code>this</code> in a function will refer to the context in which the function was called. Sometimes functions are global and sometimes they're part of a larger Object. Here's a brief example to clarify:</p>

<p>``` js
var foobar = {</p>

<pre><code>doWork: function() {
    console.log('doing some work...');
    console.log(this);
}
</code></pre>

<p>}</p>

<p>foobar.doWork(); // <code>this</code> will refer to foobar</p>

<p>var doWorkClone = foobar.doWork;
doWorkClone(); // <code>this</code> will refer to window</p>

<p>var workClones = [];
workClones.push(foobar.doWork);
workClones<a href="">0</a>; // <code>this</code> will refer to the workClones Array
```</p>

<p>The first time we call <code>doWork</code> we do so in the <em>context</em> of the <code>foobar</code> object: <code>foobar.doWork()</code>. As a result the term <code>this</code> inside of the <code>doWork</code> method will refer to <code>foobar</code>.</p>

<p>The second time we call <code>doWork</code> we do so by referencing the method through a variable. We're calling <code>doWork</code> using that variable's <em>context</em>. But the variable is a global variable, it's just hanging out on the page! As a result <code>this</code> will refer to <code>window</code>.</p>

<p>In the third example we're stuffing <code>doWork</code> into an array, then referencing it by index, then calling it. In this <em>context</em> <code>doWork</code> is scoped to the <code>workClones</code> Array, since it's also an Object. A little confusing I know.</p>

<p>So why do I care?</p>

<p>Well if you go back and look at the <code>publisher</code> example you'll notice that we pass a function reference to be called whenever the Subject sends out a notification. In our case it looks like this: <code>publisher.subscribe('login.complete', handleLogin);</code> If <code>handleLogin</code> needs to use <code>this</code> we might be in a world of hurt because <code>publisher</code> is going to call <code>handleLogin</code> using itself as the value of <code>this</code>. Uh oh!</p>

<h2>Preserving Context in Observer</h2>

<p>JavaScript's context switching can be really bizarre if you've never had to manage it before. To mitigate this problem we have a handful of useful strategies.</p>

<p>The first one, which is demonstrated in the <code>publisher</code>, is to pass along a <code>context</code> whenever we subscribe a function. This is the third argument to our <code>publisher</code>'s <code>on</code> method.</p>

<p>``` js
on: function(type, fn, context) {</p>

<pre><code>    type = type || 'any';
    fn = typeof fn === 'function' ? fn : context[fn];
    if (typeof this.subscribers[type] === "undefined") {
        this.subscribers[type] = [];
    }
    this.subscribers[type].push({ fn: fn, context: context || this });
},
</code></pre>

<p><code>``
By storing the</code>context<code>we ensure that when it's time to call our function, we can do so in the correct context with the correct value for</code>this<code>. We do this through the use of JavaScript's</code>call` method which allows us to define in which context a function should execute.</p>

<p><code>js
subscribers[i].fn.call(subscribers[i].context, arg);
</code></p>

<p>This can be a very powerful feature especially for utility functions. Checkout the MDN docs for a deeper understanding of <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function/call">call</a> and its cousin <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function/apply">apply.</a></p>

<p>But what if you're not using our <code>publisher</code> example? What if you're using a slightly more popular library like jQuery to manage your events? Maybe you have some code that looks like this:</p>

<p><code>`` js
// Substitute</code>on<code>for</code>click<code>or</code>delegate<code>or</code>live` or
// whatever else you're using :)</p>

<p>$('.login-button').on('click', function() {</p>

<pre><code>// tell the app the user is trying to log in!
</code></pre>

<p>});
```</p>

<p>Well in this case we might have to use a different approach. As anyone who's used jQuery knows, the value of <code>this</code> in our handler function is going to refer to the DOM element that jQuery selected. Sometimes that's really useful but other times, like in this case, it isn't going to do us much good.</p>

<h3>Closures</h3>

<p>Closures are a powerful feature of ECMAScript and they're especially useful when passing around functions. The best definition I've found for a closure comes from <a href="http://jibbering.com/faq/notes/closures/">this article:</a></p>

<blockquote><p>The simple explanation of a Closure is that ECMAScript allows inner functions; function definitions and function expressions that are inside the function bodies of other functions. And that those inner functions are allowed access to all of the local variables, parameters and declared inner functions within their outer function(s).</p></blockquote>

<p>So let's see that in action.</p>

<p>``` js</p>

<p>var loginController = {</p>

<pre><code>init: function() {
    var self = this;

    $('.login-button').on('click', function() {
        self.handleLogin(); // use self as a stand in for `this` 
    });
},
handleLogin: function() {
    console.log('handling login!');
}
</code></pre>

<p>}</p>

<p><code>``
In the above example the var</code>self<code>exists in a kind of interesting limbo: it is part of</code>loginController's<code></code>init<code>method and also part of the function registered as the</code>on('click')<code>handler. As a result, when the function is executed,</code>self<code>is still in the context of the</code>loginController<code>object and thus logs</code>handling login!`</p>

<p>Awesome! We've solved the issue of preserving scope, right? Well, yes but it's not our only option. Many people (myself included) find it annoying to sprinkle <code>var self = this</code> all over their app. To mitigate things we also have <code>Function.bind</code>.</p>

<h3>Bindings</h3>

<p>The addition of <code>Function.bind</code> in ECMAScript 5 allows us to specify in which context a function should be called, in other words, <em>binding</em> that function (and the value of <code>this</code>) to a particular context. Let's see it in action:</p>

<p>``` js
var widget = {</p>

<pre><code>name: 'My Awesome Widget!',
sayName: function() {
    console.log(this.name);
}
</code></pre>

<p>};</p>

<p>var nameFunc = widget.sayName.bind(widget);
nameFunc(); // outputs: 'My Awesome Widget!'
```</p>

<p>Calling <code>Function.bind</code> will actually create a closure preserving whatever scope we've passed in. It returns a clone of our original function but this time it is bound to a particular context. In the above example it's bound to the <code>widget</code> object. While it's cleaner than our original closure example we're still in a dilemma because we want <code>sayName</code> to ALWAYS be called in the context of <code>widget</code>. How about something like this instead: <code>widget.sayName = widget.sayName.bind(widget);</code> Hey, now we're talking! By overwriting our function and binding it to our <code>widget</code> object we've gotten very close to how classical languages like Java and Actionscript handle scope! This means it's easy to both subscribe and unsubscribe our method, safe in the knowledge that it will always use the proper scope. If you're lazy (like me) take some time to research <a href="http://underscorejs.org/">Underscore.js</a> which provides both <a href="http://underscorejs.org/#bind">bind</a> and <a href="http://underscorejs.org/#bindAll">bindAll</a> functions to ease the process of connecting your methods to their parent objects.</p>

<p>I'll save you the speech on treating JavaScript like other languages except to say anytime you're writing code to make one language act like another you should obviously research whether that's the best course of action or not. In my experience I've found that binding observers can make writing event listeners much cleaner but your mileage may vary and comments/feedback are always welcome :D</p>

<p>Also if you want to read more on <code>Function.bind</code> you can do so <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function/bind">here on MDN.</a></p>

<h2>The Push and Pull Model</h2>

<p>Typically when you create a Subject/Observer relationship you'll want the Subject to send along additional information during its event dispatch. The amount of information can vary widely. Sometimes you'll want to send a lot of information and other times you'll want the observers to receive the event and then query for more information. When you're sending a lot of information it's referred to as the <em>push model</em> and when the Observers should query for more information it's referred to as the <em>pull model</em>. The Gang of Four describe the differences between the two:</p>

<blockquote><p>The pull model emphasizes the subject’s ignorance of its observers, whereas the push model assumes subjects know something about their observers’ needs. The push model might make observers less reusable, because Subject classes make assumptions about Observer classes that might not always be true. On the other hand, the pull model may be inefficient, because Observer classes must ascertain what changed without help from the Subject.</p></blockquote>

<p>There's no right or wrong approach but it is good to understand the differences between the two.</p>

<h2>PubSub and Observer mixins</h2>

<p>If you want a quick, easy to use event dispatcher the <a href="https://github.com/mroderick/PubSubJS">PubSubJS</a> library does a wonderful job of providing an easy to use event dispatcher. It also includes a jQuery plugin variant if that's more your style. If you're looking for something a little less global and a bit more OO checkout this utility function from <a href="http://www.amazon.com/JavaScript-Patterns-Stoyan-Stefanov/dp/0596806752">JavaScript Patterns</a> which mixes-in the <code>publisher</code> to other objects.</p>

<p>``` js
function makePublisher(o) {</p>

<pre><code>var i;   
for (i in publisher) {     
    if (publisher.hasOwnProperty(i) &amp;&amp; typeof publisher[i] === "function") {
        o[i] = publisher[i];     
    }   
}
o.subscribers = {
    any: []
};
</code></pre>

<p>}
```</p>

<h2><a href="https://github.com/robdodson/JavaScript-Design-Patterns/tree/master/observer/">Grab the Example Source</a></h2>

<h2>Related Patterns</h2>

<ul>
<li>Promise: A Promise is an observable token given from one object to another. Promises wrap an operation and notify their observers when the operation either succeeds or fails.</li>
</ul>


<p><small><cite style="color:#AAA;">Gamma, Erich; Helm, Richard; Johnson, Ralph; Vlissides, John (1994-10-31). Design Patterns: Elements of Reusable Object-Oriented Software. Pearson Education (USA).</cite></small></p>

<hr>


<br>


<h4><a href="http://robdodson.me/blog/2012/08/03/javascript-design-patterns/">Table of Contents</a></h4>

<br>


<p>Thanks for reading! If you have questions or feedback please leave a comment below. - Rob</p>

<p>You should follow me on Twitter <a href="http://twitter.com/rob_dodson">here.</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript Design Patterns: Iterator]]></title>
    <link href="http://robdodson.me/blog/2012/08/10/javascript-design-patterns-iterator/"/>
    <updated>2012-08-10T15:45:00-07:00</updated>
    <id>http://robdodson.me/blog/2012/08/10/javascript-design-patterns-iterator</id>
    <content type="html"><![CDATA[<h4><a href="http://robdodson.me/blog/2012/08/03/javascript-design-patterns/">Table of Contents</a></h4>

<p>If you're coming from Ruby or Java you probably think of an Iterator as an object which gives you a consistent interface for traversing a collection of some kind. If you're coming from JavaScript or Actionscript you probably just think of an iterator as the <code>i</code> value in a <code>for</code> loop. The term has mixed meanings but in this case we're refering to the former, an object which gives us a consistent interface for iterating over a collection of some kind. If you've never used them before that might seem kind of silly. "If I need to loop over something I'm just going to loop over it!" For many use cases that's totally fine. Where Iterator objects are useful is in situations where you might need to loop in an async fashion (stopping and restarting) or if you want to preclude an object from knowing too much about the inner workings of a collection.</p>

<!--more-->


<h2>Formal Definition</h2>

<p><blockquote><p>Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation.</p><footer><strong>GoF</strong> <cite>Design Patterns: Elements of Reusable Object-Oriented Software</cite></footer></blockquote></p>

<h3>Also Known As</h3>

<ul>
<li>Cursor</li>
</ul>


<h2>Example Time</h2>

<p>The code for an Iterator should be pretty easy to grok if you've worked with loops before. Here is a simple example which returns an Iterator for looping over an Array by every third value.</p>

<p>``` js
var iterator = (function() {</p>

<pre><code>var index = 0,
    data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
    length = data.length;

return {
    next: function() {
        var element;
        if (!this.hasNext()) {
            return null;
        }
        element = data[index];
        index += 3;
        return element;
    },
    hasNext: function() {
        return index &lt; length;
    },
    rewind: function() {
        index = 0;
        return data[index];
    },
    current: function() {
        return data[index];
    }
}
</code></pre>

<p>}());
<code>``
Our iterator has a handful of useful operations including</code>next<code>,</code>hasNext<code>,</code>rewind<code>and</code>current`.</p>

<p><code>next</code> will return the next value and advance the index by 3.</p>

<p><code>hasNext</code> will check to see if calling <code>next</code> will actually return an item. Good for indicating when we've reached the end of a collection.</p>

<p><code>rewind</code> will reset the index to zero so we can loop over the collection again.</p>

<p><code>current</code> will return the current item at the index without advancing the index.</p>

<p>Let's put these into play to see how it works:</p>

<p>``` js
while(iterator.hasNext()) {</p>

<pre><code>console.log(iterator.next());
</code></pre>

<p>}</p>

<p>iterator.rewind();
console.log(iterator.current());
```</p>

<p>If we ran the above we'd see the following output in the console.</p>

<p><code>
1
4
7
10
1
</code>
Since the iterator is mainting its own state if we need to stop iteration at any point we just don't call <code>next</code>. Using exclusively <code>for</code> loops we'd have to check against a flag of some kind, store our current position and then rebuild the loop starting from that point.</p>

<h2>Not just for Arrays</h2>

<p>As I mentioned before the Iterator gives us a consistent interface for traversing a collection, which means it can iterate over <em>any</em> object. Calendar Dates, Linked Lists, Node Graphs, whatever! Here's an example of an iterator that traverses a simple Hash.</p>

<p>``` js
var iterator = (function() {</p>

<pre><code>var data = { foo: 'foo', bar: 'bar', baz: 'baz' },
    keys = Object.keys(data),
    index = 0,
    length = keys.length;

return {
    next: function() {
        var element;
        if (!this.hasNext()) {
            return null;
        }
        element = data[keys[index]];
        index++;
        return element;
    },
    hasNext: function() {
        return index &lt; length;
    },
    rewind: function() {
        index = 0;
        return data[keys[index]];
    },
    current: function() {
        return data[keys[index]];
    }
}
</code></pre>

<p>}());
```
Notice how the interface is identical to our previous Iterator? That's one of the key aspects to this pattern: Regardless of the <em>type</em> of collection, we can define a consistent interface to loop through it. It also means that the client doesn't need to know anything about the implementation of the actual collection, and by wrapping it in a closure we can prevent the client from <em>editing</em> the collection. Personally I like the idea of certain services handing out iterators rather than a wholesale dump of all the data. As always use whichever tool is appropriate for the context.</p>

<p>One quick note regarding Hashes. Previous versions of the ECMA spec did not require that Hash keys be kept in order. While most modern browsers <em>do</em> keep them in order there are some funky inconsistencies. For instance, if you write out the following Hash:</p>

<p><code>js
var hash = { 'foo': 'foo', 'bar': 'bar', '1': 'hello', '2': 'world' };
</code>
Google Chrome will swap the order of the keys such that they appear like this:</p>

<p><code>js
{ '1': 'hello', '2': 'world', 'foo': 'foo', 'bar': 'bar' };
</code>
There are some interesting discussions on StackOverflow which cover this topic but it's a bit outside the scope of this article. If you're interested you can find them here:</p>

<ul>
<li><a href="http://stackoverflow.com/questions/5773950/how-to-keep-an-javascript-object-array-ordered-while-also-maintaining-key-lookup">How to keep an Javascript object/array ordered while also maintaining key lookups?</a></li>
<li><a href="http://stackoverflow.com/questions/3549894/javascript-data-structure-for-fast-lookup-and-ordered-looping">Javascript data structure for fast lookup and ordered looping?</a></li>
</ul>


<h2>JavaScript 1.7</h2>

<p>Although not widely supported yet, JavaScript 1.7 includes a built in Iterator object which can be used to wrap an Array or Hash with just a single line of code.</p>

<p>``` html</p>

<script type="application/javascript;version=1.7">
    var lang = { name: 'JavaScript', birthYear: 1995 };
    var it = Iterator(lang);
</script>


<p><code>``
The above script block will not work in Chrome but it should work in the latest version of Firefox. Note the</code>type` attribute of the script tag which instructs the interpreter to handle the code as JS 1.7.</p>

<p>For some further reading on the topic checkout the MDN article which covers <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Iterators_and_Generators">Iterators in JavaScript 1.7</a></p>

<h2><a href="https://github.com/robdodson/JavaScript-Design-Patterns/tree/master/iterator/">Grab the Example Source</a></h2>

<h2>Related Patterns</h2>

<ul>
<li>Composite: Iterators are often applied to recursive structures such as Composites.</li>
<li>Factory Method: Polymorphic iterators rely on factory methods to instantiate the appropriate Iterator subclass.</li>
<li>Memento: Often used in conjunction with the Iterator pattern. An iterator can use a memento to capture the state of an iteration. The iterator stores the memento internally.</li>
</ul>


<p><small><cite style="color:#AAA;">Gamma, Erich; Helm, Richard; Johnson, Ralph; Vlissides, John (1994-10-31). Design Patterns: Elements of Reusable Object-Oriented Software. Pearson Education (USA).</cite></small></p>

<hr>


<br>


<h4><a href="http://robdodson.me/blog/2012/08/03/javascript-design-patterns/">Table of Contents</a></h4>

<br>


<p>Thanks for reading! If you have questions or feedback please leave a comment below. - Rob</p>

<p>You should follow me on Twitter <a href="http://twitter.com/rob_dodson">here.</a></p>
]]></content>
  </entry>
  
</feed>
